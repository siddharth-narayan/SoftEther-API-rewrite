// GetCurrentTimezone()
// SetDhParam(DH_CTX*dh)
// IsUseAlternativeHostname()
// SendPack(SOCK*s,PACK*p)
// RecvPack(SOCK*s)
// RecvPackWithHash(SOCK*s)
// SendPackWithHash(SOCK*s,PACK*p)
// GetErrorFromPack(PACK*p)
// PackError(UINTerror)
// DetectFletsType()
// NewRUDPClientDirect(char*svc_name,IP*ip,UINTport,UINT*error_code,UINTtimeout,bool*cancel,SOCK*sock,SOCK_EVENT*sock_event,UINTlocal_port,boolover_dns_mode)
// GetCurrentMachineIpProcessHash(void*hash)
// ListenRUDPEx(char*svc_name,RUDP_STACK_INTERRUPTS_PROC*proc_interrupts,RUDP_STACK_RPC_RECV_PROC*proc_rpc_recv,void*param,UINTport,boolno_natt_register,boolover_dns_mode,volatileUINT*natt_global_udp_port,UCHARrand_port_id,IP*listen_ip)
// InitWaitUntilHostIPAddressChanged()
// FreeWaitUntilHostIPAddressChanged(void*p)
// WaitUntilHostIPAddressChanged(void*p,EVENT*event,UINTtimeout,UINTip_check_interval)
// GetHostIPAddressHash32()
// GetMyPrivateIP(IP*ip,boolfrom_vg)
// GenRandInterval(UINTmin,UINTmax)
// RUDPGetRegisterHostNameByIP(char*dst,UINTsize,IP*ip)
// RUDPParseIPAndPortStr(void*data,UINTdata_size,IP*ip,UINT*port)
// ParseNtUsername(char*src_username,char*dst_username,UINTdst_username_size,char*dst_domain,UINTdst_domain_size,booldo_not_parse_atmark)
// UnixGetDefaultDns(IP*ip)
// UnixDeletePipe(intp1,intp2)
// UnixSetSocketNonBlockingMode(intfd,boolnonblock)
// StrToIP(IP*ip,char*str)
// StrToIP32(char*str)
// UniStrToIP32(wchar_t*str)
// IPToStr(char*str,UINTsize,IP*ip)
// IPToStr32(char*str,UINTsize,UINTip)
// IPToStr4or6(char*str,UINTsize,UINTip_4_uint,UCHAR*ip_6_bytes)
// IPToUniStr(wchar_t*str,UINTsize,IP*ip)
// IPToUniStr32(wchar_t*str,UINTsize,UINTip)
// GetHostName(char*hostname,UINTsize,IP*ip)
// GetMachineName(char*name,UINTsize)
// GetMachineHostName(char*name,UINTsize)
// UINTToIP(IP*ip,UINTvalue)
// IPToUINT(IP*ip)
// ReleaseSock(SOCK*s)
// Connect(char*hostname,UINTport)
// ConnectEx(char*hostname,UINTport,UINTtimeout)
// ConnectEx2(char*hostname,UINTport,UINTtimeout,bool*cancel_flag)
// ConnectEx3(char*hostname,UINTport,UINTtimeout,bool*cancel_flag,char*nat_t_svc_name,UINT*nat_t_error_code,booltry_start_ssl,boolno_get_hostname)
// ConnectEx4(char*hostname,UINTport,UINTtimeout,bool*cancel_flag,char*nat_t_svc_name,UINT*nat_t_error_code,booltry_start_ssl,boolno_get_hostname,IP*ret_ip)
// BindConnectEx5(IP*localIP,UINTlocalport,char*hostname,UINTport,UINTtimeout,bool*cancel_flag,char*nat_t_svc_name,UINT*nat_t_error_code,booltry_start_ssl,boolno_get_hostname,SSL_VERIFY_OPTION*ssl_option,UINT*ssl_err,char*hint_str,IP*ret_ip)
// SetTtl(SOCK*sock,UINTttl)
// Disconnect(SOCK*sock)
// Listen(UINTport)
// ListenEx(UINTport,boollocal_only)
// ListenEx2(UINTport,boollocal_only,boolenable_ca,IP*listen_ip)
// ListenEx6(UINTport,boollocal_only)
// ListenEx63(UINTport,boollocal_only,boolenable_ca,IP*listen_ip)
// Accept(SOCK*sock)
// Send(SOCK*sock,void*data,UINTsize,boolsecure)
// Recv(SOCK*sock,void*data,UINTsize,boolsecure)
// Peek(SOCK*sock,void*data,UINTsize)
// SetNoNeedToRead(SOCK*sock)
// StartSSL(SOCK*sock,X*x,K*priv)
// StartSSLEx(SOCK*sock,X*x,K*priv,UINTssl_timeout,char*sni_hostname)
// StartSSLEx3(SOCK*sock,X*x,K*priv,LIST*chain,UINTssl_timeout,char*sni_hostname,SSL_VERIFY_OPTION*ssl_option,UINT*ssl_err)
// SendAll(SOCK*sock,void*data,UINTsize,boolsecure)
// SendAdd(SOCK*sock,void*data,UINTsize)
// SendNow(SOCK*sock,intsecure)
// RecvAll(SOCK*sock,void*data,UINTsize,boolsecure)
// RecvAllWithDiscard(SOCK*sock,UINTsize,boolsecure)
// InitSockSet(SOCKSET*set)
// AddSockSet(SOCKSET*set,SOCK*sock)
// NewCancel()
// ReleaseCancel(CANCEL*c)
// Cancel(CANCEL*c)
// Select(SOCKSET*set,UINTtimeout,CANCEL*c1,CANCEL*c2)
// SetWantToUseCipher(SOCK*sock,char*name)
// NewUDP(UINTport)
// NewUDPEx(UINTport,boolipv6)
// NewUDPEx2(UINTport,boolipv6,IP*ip)
// NewUDPEx3(UINTport,IP*ip)
// NewUDP4(UINTport,IP*ip)
// ClearSockDfBit(SOCK*s)
// SetRawSockHeaderIncludeOption(SOCK*s,boolenable)
// SendTo(SOCK*sock,IP*dest_addr,UINTdest_port,void*data,UINTsize)
// RecvFrom(SOCK*sock,IP*src_addr,UINT*src_port,void*data,UINTsize)
// SetTimeout(SOCK*sock,UINTtimeout)
// CheckTCPPort(char*hostname,UINTport)
// JoinSockToSockEvent(SOCK*sock,SOCK_EVENT*event)
// NewSockEvent()
// SetSockEvent(SOCK_EVENT*event)
// WaitSockEvent(SOCK_EVENT*event,UINTtimeout)
// ReleaseSockEvent(SOCK_EVENT*event)
// SetIP(IP*ip,UCHARa1,UCHARa2,UCHARa3,UCHARa4)
// SetIP32(UCHARa1,UCHARa2,UCHARa3,UCHARa4)
// GetDefaultDns(IP*ip)
// GetDomainName(char*name,UINTsize)
// AcceptInit(SOCK*s)
// AcceptInitEx(SOCK*s,boolno_lookup_hostname)
// DisableGetHostNameWhenAcceptInit()
// GetCipherList()
// GetNumTcpConnectionsCounter()
// AddWaitThread(THREAD*t)
// DelWaitThread(THREAD*t)
// IsSubnetMask4(IP*ip)
// IsSubnetMask32(UINTip)
// IsNetworkAddress32(UINTip,UINTmask)
// IsHostIPAddress4(IP*ip)
// IsHostIPAddress32(UINTip)
// IsZeroIP(IP*ip)
// IsZeroIP6Addr(IPV6_ADDR*addr)
// NormalizeMacAddress(char*dst,UINTsize,char*src)
// NewSockList()
// FreeSockList(SOCKLIST*sl)
// IsIPv6Supported()
// SetSockHighPriority(SOCK*s,boolflag)
// GetNumIpClient(IP*ip)
// SetLinuxArpFilter()
// NewRouteChange()
// FreeRouteChange(ROUTE_CHANGE*r)
// IsRouteChanged(ROUTE_CHANGE*r)
// AddProtocolDetailsStr(char*dst,UINTdst_size,char*str)
// AddProtocolDetailsKeyValueInt(char*dst,UINTdst_size,char*key,UINTvalue)
// CopyIP(IP*dst,IP*src)
// IsIP4(IP*ip)
// IPv6AddrToIP(IP*ip,IPV6_ADDR*addr)
// IPToIPv6Addr(IPV6_ADDR*addr,IP*ip)
// SetIP6(IP*ip,UCHAR*value)
// GetLocalHostIP4(IP*ip)
// IsLocalHostIP4(IP*ip)
// IsLocalHostIP(IP*ip)
// ZeroIP4(IP*ip)
// StrToIP6(IP*ip,char*str)
// IPToStr6(char*str,UINTsize,IP*ip)
// IP6AddrToStr(char*str,UINTsize,IPV6_ADDR*addr)
// IntToSubnetMask6(IP*ip,UINTi)
// IPAnd6(IP*dst,IP*a,IP*b)
// GetAllRouterMulticastAddress6(IP*ip)
// GetIPAddrType6(IP*ip)
// GetIPv6AddrType(IPV6_ADDR*addr)
// IsInSameNetwork6(IP*a1,IP*a2,IP*subnet)
// GenerateEui64Address6(UCHAR*dst,UCHAR*mac)
// GenerateEui64LocalAddress(IP*a,UCHAR*mac)
// SubnetMaskToInt(IP*a)
// SubnetMaskToInt6(IP*a)
// IPAnd4(IP*dst,IP*a,IP*b)
// IsInSameNetwork4(IP*a1,IP*a2,IP*subnet)
// IsValidUnicastIPAddress4(IP*ip)
// IsValidUnicastIPAddressUINT4(UINTip)
// IsValidUnicastIPAddress6(IP*ip)
// IsMacUnicast(UCHAR*mac)
// IsMacBroadcast(UCHAR*mac)
// IsMacMulticast(UCHAR*mac)
// IsMacInvalid(UCHAR*mac)
// ParseIpAndSubnetMask4(char*src,UINT*ip,UINT*mask)
// ParseIpAndMask4(char*src,UINT*ip,UINT*mask)
// ParseIpAndMask6(char*src,IP*ip,IP*mask)
// ParseIpAndMask46(char*src,IP*ip,IP*mask)
// IsIpStr4(char*str)
// MaskToStr(char*str,UINTsize,IP*mask)
// Mask6AddrToStr(char*str,UINTsize,IPV6_ADDR*mask)
// MaskToStr32(char*str,UINTsize,UINTmask)
// FreeTubeData(TUBEDATA*d)
// NewTube(UINTsize_of_header)
// ReleaseTube(TUBE*t)
// TubeSendEx(TUBE*t,void*data,UINTsize,void*header,boolno_flush)
// TubeFlush(TUBE*t)
// TubeFlushEx(TUBE*t,boolforce)
// TubeRecvAsync(TUBE*t)
// TubeRecvSync(TUBE*t,UINTtimeout)
// NewTubePair(TUBE**t1,TUBE**t2,UINTsize_of_header)
// TubeDisconnect(TUBE*t)
// IsTubeConnected(TUBE*t)
// SetTubeSockEvent(TUBE*t,SOCK_EVENT*e)
// NewTubeFlushList()
// FreeTubeFlushList(TUBE_FLUSH_LIST*f)
// AddTubeToFlushList(TUBE_FLUSH_LIST*f,TUBE*t)
// FlushTubeFlushList(TUBE_FLUSH_LIST*f)
// GetHostIPAddressList()
// FreeHostIPAddressList(LIST*o)
// GetHostIPAddressListHash()
// NewUdpListener(UDPLISTENER_RECV_PROC*recv_proc,void*param,IP*listen_ip)
// StopUdpListener(UDPLISTENER*u)
// FreeUdpListener(UDPLISTENER*u)
// AddPortToUdpListener(UDPLISTENER*u,UINTport)
// DeletePortFromUdpListener(UDPLISTENER*u,UINTport)
// DeleteAllPortFromUdpListener(UDPLISTENER*u)
// UdpListenerSendPackets(UDPLISTENER*u,LIST*packet_list)
// NewTcpRawData(IP*src_ip,UINTsrc_port,IP*dst_ip,UINTdst_port)
// FreeTcpRawData(TCP_RAW_DATA*trd)
// NewUdpPacket(IP*src_ip,UINTsrc_port,IP*dst_ip,UINTdst_port,void*data,UINTsize)
// FreeUdpPacket(UDPPACKET*p)
// IsUdpPortOpened(UDPLISTENER*u,IP*server_ip,UINTport)
// NewInterruptManager()
// FreeInterruptManager(INTERRUPT_MANAGER*m)
// AddInterrupt(INTERRUPT_MANAGER*m,UINT64tick)
// GetNextIntervalForInterrupt(INTERRUPT_MANAGER*m)
// NewSocketPair(SOCK**client,SOCK**server,IP*client_ip,UINTclient_port,IP*server_ip,UINTserver_port)
// ListenInProc()
// ConnectInProc(SOCK*listen_sock,IP*client_ip,UINTclient_port,IP*server_ip,UINTserver_port)
// WaitForTubes(TUBE**tubes,UINTnum,UINTtimeout)
// ListenReverse()
// InjectNewReverseSocketToAccept(SOCK*listen_sock,SOCK*s,IP*client_ip,UINTclient_port)
// IcmpApiEchoSend(IP*dest_ip,UCHARttl,UCHAR*data,UINTsize,UINTtimeout)
// IcmpApiFreeResult(ICMP_RESULT*ret)
// NewSslPipe(boolserver_mode,X*x,K*k,DH_CTX*dh)
// NewSslPipeEx(boolserver_mode,X*x,K*k,DH_CTX*dh,boolverify_peer,structSslClientCertInfo*clientcert)
// NewSslPipeEx3(boolserver_mode,X*x,K*k,LIST*chain,DH_CTX*dh,boolverify_peer,structSslClientCertInfo*clientcert,inttls13ticketscnt,booldisableTls13)
// FreeSslPipe(SSL_PIPE*s)
// SyncSslPipe(SSL_PIPE*s)
// SetCurrentGlobalIP(IP*ip,boolipv6)
// GetCurrentGlobalIP(IP*ip,boolipv6)
// GetCurrentGlobalIPGuess(IP*ip,boolipv6)
// IsIPPrivate(IP*ip)
// IsIPMyHost(IP*ip)
// IsMacAddressLocalFast(void*addr)
// RefreshLocalMacAddressList()
// GetOSSecurityLevel()
// SetCurrentDDnsFqdn(char*name)
// ExtractAndApplyDynList(PACK*p)
// GetDynValueOrDefaultSafe(char*name,UINT64default_value)

pub extern "C" fn GetCurrentTimezone() -> i32 {
    return 0;
}